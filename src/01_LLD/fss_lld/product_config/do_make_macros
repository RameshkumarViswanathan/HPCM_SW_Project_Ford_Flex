#!/usr/bin/env perl
# Description:	compute make macro
use 5.010001;
use strict;
use warnings FATAL => 'all';
use autodie;
use English;
use POSIX;
use Getopt::Long;
use File::Basename;
use File::Spec;
use File::Spec::Functions;
use File::Spec::Functions 'abs2rel';
use File::Spec 'canonpath';
use IPC::Open3;

alarm 10;
my $version = '%version: 32 %';		# Special string updated by synergy
$version =~ s/^.*? | %//g;
our $VERSION = $version;
use FindBin;
push (@INC, $FindBin::RealBin);
require MM_common;

#--- main
my %blacklist;
my %ext =
(
 	x => 'xsm',	# eXtended S-Motorola
	S => 'S',	# C preprocessing-Assembly
	s => 's',	# Assembly
	o => 'o',	# Object
	a => 'a',	# Archive
	i => ''		# Intermediate
);
our $opt_lib_listing = 'ar -t';
our $opt_dcm_delimiter = '#';
our $opt_delimiter = '-';
our @opt_dests = ();
our $opt_ecu_hw = '';
our $opt_incl_flag = '-I';
our $opt_note;
my %unarchived_objects;
our $opt_project = '';
Getopt::Long::Configure(qw(require_order no_pass_through no_bundling));
GetOptions(
					# Files discarded
	'blacklist|b=s' => sub {$blacklist{$_[1]} = 0},
	'dcm_delimiter|c=s',		# dcm delimiter
	'delimiter|d=s',		# ccm delimiter
	'dests|D=s@{,}',		# all dests
	'ext|e=s%{,6}' => \%ext,	# File extensions
					# Objects to be linked directly
	'objects|O=s' => sub {$unarchived_objects{$_[1]} = ''},
	'incl_flag|I=s',		# compiler option for include path
	'lib_listing|L=s',		# Library listing command
	'note|n=s',			# Note
	'project|p=s',			# Project
	'ecu_hw|w=s'			# ECU HW
) or MM_common::help();
$OUTPUT_RECORD_SEPARATOR=$INPUT_RECORD_SEPARATOR;
my $proj_name = '';
my $ecu_sw = '';
if ($opt_project eq '')
	{warn("option project isn't defined$RS") if $Carp::Verbose}
else
{
	$opt_project =~ s/.+(?=${opt_delimiter})//;
	$proj_name = $MATCH;
	printf "FAMILY = %.2s$RS", $proj_name;
	printf "FAMILY_CHAR = %.1s$RS", $proj_name;
	$opt_project =~ /(?:.*?${opt_dcm_delimiter})?(?'ecu_sw'.*)/;
	$ecu_sw = $+{ecu_sw};
	$ecu_sw =~ s/_//g;
	$ecu_sw = substr($ecu_sw, 0, 4);
	print "ECU_SW = $ecu_sw"
}
if ($opt_note eq '')
	{warn("option note isn't defined$RS") if $Carp::Verbose}
else
	{print "NOTE = $opt_note"}
if ($opt_ecu_hw eq '')
{
	warn("option ecu_hw isn't defined$RS") if $Carp::Verbose
}
else
{
	print "ECU_HW = $opt_ecu_hw";
	my $code_extension_file = 'other_files/product_config/CODE_EXTENSION';
	if (-r $code_extension_file)
	{
		my %dests;
		open(STDIN, '<', $code_extension_file);
		foreach (<STDIN>)
		{
			chomp $_;
			my ($id, $ecu_hw, $dest) = split(' ', $_, 4);
			if ($ecu_hw eq $opt_ecu_hw)
			{
				die("double VERSION_SW in '$code_extension_file'" .
					"for '$dests{$dest}' '$dest' and $RS")
							if exists $dests{$dest};
				$dests{$dest} = '';
				print "VERSION_SW_$dest := " .
						"${proj_name}${id}${ecu_sw}"
			}
		}
		map {warn("missing VERSION_SW in '$code_extension_file' for " .
							"$opt_ecu_hw/$_$RS")
					unless exists $dests{$_}} @opt_dests
	}
}
my %view_path;
my %libs;
my @extra_lib;	# Additional libraries (already archived)
my $i_list;	# List of C intermediate files
my %object;
my @c_sources;
my @not_c_sources;
open(DEVNULL, '>', File::Spec->devnull);

foreach my $layer (@ARGV)			# Cicle on the layers
{
	my @incl_paths = "";
	open(STDIN, '<', "${layer}_incl");	# Read layer's incl file
	push(@incl_paths, <STDIN>);
	close(STDIN);
	chomp @incl_paths;
	foreach (@incl_paths)
	{
		$_ =~ s/^$opt_incl_flag\s*//;
		$_ = abs2rel($_);
		$view_path{$_} = '';
		warn("view path '$_'$RS") if $Carp::Verbose
	}
	my @sources;
	open(STDIN, '<', "${layer}.s_list");	# Read layer's s_list file
	@sources = <STDIN>;
	close(STDIN);
	chomp @sources;
	foreach (@sources)		# Cicle through all layer's sources
	{
		if (m/^BLACKLISTED (?'blacklisted'.*)/)
		{
			delete $blacklist{"$+{blacklisted}"}
					if exists $blacklist{"$+{blacklisted}"};
			next
		}
		$_ = abs2rel($_);
		my ($filename, $dirs, $suffix) = fileparse($_, qr/\.[^.]*/);
		$dirs = File::Spec->canonpath($dirs);
		$view_path{$dirs} = '';
		warn("view path '$dirs'$RS") if $Carp::Verbose;
		next if $suffix =~ /\.(?:dd|a2l)/;	# dd/a2l
		if ($suffix eq ".$ext{a}")	# Extra libraries
		{
			my $library = $_;
				# Use open3 to silent stderr
			my($wtr, $rdr);
			my $pid = open3($wtr, $rdr, ">&DEVNULL",
						"$opt_lib_listing $library");
			while (<$rdr>)	# Objects in extra library
			{
				chomp;
				($filename, undef, $suffix) =
						fileparse($_, qr/\.[^.]*/);
				die("duplicated '$filename.*': in '$library'" .
						" and '$object{$filename}'$RS")
						if defined $object{$filename};
				$object{$filename} = $library;
				warn("source '${filename}$suffix' " .
					"in ${library}$RS") if $Carp::Verbose
			}
			$library = basename($library);
			push @extra_lib, $library;
			next
		}
						# Objects, C/assmebly
		die "duplicated '$filename.*' in '$dirs' and " .
						"'$object{$filename}'$RS"
						if defined $object{$filename};
		$object{"$filename"} = $dirs;
		if ($suffix =~ /\.(?:c|$ext{x})/)
			{push @c_sources, $filename}
		else			# .$ext{S}, .$ext{s} or .$ext{o}
			{push @not_c_sources, $filename}
		warn("source '${filename}$suffix'$RS") if $Carp::Verbose;
						# C/assmebly
		print "${filename}_LAYER := ${layer}" if $suffix ne ".$ext{o}";
			# Going to list library or clean unarchived_objects
		if (exists($unarchived_objects{$filename.$ext{o}}))
			{delete $unarchived_objects{$filename.$ext{o}}}
		else	{$libs{"$layer.$ext{a}"} = ''}
	}
}

warn ("blacklisted '$_' isn't present in project$RS") foreach (keys %blacklist);
$OUTPUT_FIELD_SEPARATOR = ' ';
printf "LIBS := ";
my @libs = keys %libs;
print @libs;
print "EXTRA_LIB := @extra_lib";
print 'ALL_C_SRC =', @c_sources;
print 'I_FILES =', map("$_.$ext{i}", @c_sources) if $ext{i};
print 'ALL_OBJS =', map{"$_.$ext{o}"} (@c_sources, @not_c_sources);
print 'VDEP :=', keys %view_path

__END__

=head1 NAME

do_make_macros - compute make macro

=head1 SYNOPSIS

do_make_macros [options] layer_list

=head1 DESCRIPTION

 Compute make macros for MM-PWT's T&M makefiles:
 FAMILY := 2 firsts charaters of -p option
 FAMILY_CHAR := first charaters of -p option
 NOTE := -n option
 ECU_SW := 4 firsts characters of -p option, without '_'
 ECU_HW := -w option
 VERSION_SW_<dest> := composed with other_files/product_config/CODE_EXTENSION
 <sources>_LAYER := layer of any source
 LIBS := layers' libraries list
 EXTRA_LIB := list of libraries already archived
 ALL_C_SRC = list of all C sources basenames
 I_FILES = eventual list of intermediate files
 ALL_OBJS := list of all objectnames
 VDEP := paths of sources and included (fronm .incl file)

=head1 OPTIONS

 -c --dcm_delimiter <dcm delimiter>		(default '#')
 -d --delimiter	<name-version delimiter>	(default '-')
 -D --dests <dests list>,			all dests
 -e --ext <k>=<v>	Compiler extensions; valid keys and default values are:
 	x => 'xsm',	# eXtended S-Motorola
	S => 'S',	# C preprocessing-Assembly
	s => 's',	# Assembly
	o => 'o',	# Object
	a => 'a',	# Archive
	i => ''		# Intermediate
 -I --incl_flag <include path compiler option>	(default '-I')
 -L --lib_listing <Library listing command>	(default 'ar -t')
 -n --note <note string>
 -O --obj <additional objects list>
 -p --project <ccm project>
 -w --ecu_hw <ECU HW>

=head1 AUTOR

TechM

=head1 COPYRIGHT

(c) Copyright 2022 
