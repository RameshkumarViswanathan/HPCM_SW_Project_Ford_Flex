#!/usr/bin/env perl
use 5.010001;
use strict;
use warnings FATAL => 'all';
use English;
use POSIX;
use Getopt::Long;
use File::Basename;
use File::Find;
use File::Spec;
$main::VERSION = '%version: 7 %';
alarm 600;
use FindBin;
push (@INC, $FindBin::RealBin);
require MM_common;
$OUTPUT_RECORD_SEPARATOR=$INPUT_RECORD_SEPARATOR;

my %incl;
my @prj_list = ('.');
my @sources;
my @sources_names;
our $opt_inc = '-I';
our $opt_compiler = 'C:\GHS\PPC-V.R950\comp_201354\ccppc.exe';
our $opt_cppflags;
our $opt_cflags;
our $opt_wa_relative = '';	# default work area is absolute
require build if -e 'build.pm';
Getopt::Long::Configure(qw(require_order no_pass_through));
GetOptions(
	'inc|I=s',		# Include path compiler option
	'compiler|c=s',		# Compiler executable
	'cflags|f=s@',		# Compiler option
	'cppflags|p=s@',	# C-Preprocessor flags
	'wa_relative|w!',	# Work area is relative
) or MM_common::help();
if (!$opt_wa_relative)
{
	# Scans project hierarchy to be compatible with non relative work area
	my $project = `ccm status`;
	die("no cmsynergy sessions found$RS")
		if ($CHILD_ERROR != 0) or ($project =~ /No sessions found/);
	$project =~ s/.*Current project:\s+//s;
	chomp $project;
	die("not in a cmsynergy project$RS")
					if $project =~ /not be identified./;
	if ($project !~ /.*:.*/)
	{
		my $subsystem =
			`ccm attribute -show subsystem -project $project`;
		chomp $subsystem;
		$project .= ":project:$subsystem"
	}
		# Collect the whole projects hierarcy
	my $query = 'ccm query -type project ';
	$query .= "\"recursive_is_member_of('$project',none)\"";
	$query .= " -no_sort -u -f %wa_path";
	push @prj_list, `$query`;
	die("Project hierarchy scan failed$RS") if $CHILD_ERROR != 0;
	chomp @prj_list;
}
sub wanted($);
my %find_options =
(
	wanted => \&wanted,
	follow => 0,
	no_chdir => 1
);
find(\%find_options, @prj_list);
	# Prepare a clean output
if (-e (map "$_.o", @sources_names))
{
	die("Unable to remove previous objects: $ERRNO")
				unless unlink (map "$_.o", @sources_names);
}
	# Write inclusion directories as compiler option.
open INCL, '>', 'incl';
print INCL "${opt_inc}$_ " foreach (keys %incl);
close INCL;
$opt_cflags .= ' @incl';
my @command = ($opt_compiler, $opt_cppflags, $opt_cflags, @sources);
system("@command");
my $cc_error = $CHILD_ERROR;
warn("Unable to remove lst: $ERRNO")
				unless unlink (map "$_.lst", @sources_names);
warn("Unable to remove dbo: $ERRNO")
				unless unlink (map "$_.dbo", @sources_names);
if ($cc_error != 0)
{
	my $message;
	if ($CHILD_ERROR == -1)
	{
		$message = "failed to execute '@command': ${ERRNO}"
	}
	else
	{
		$message = sprintf "'@command' exited with value %d",
							$CHILD_ERROR >> 8;
	}
	die "${message}$RS"
}
warn("Unable to remove ghs' global debug files: $ERRNO")
				unless unlink (glob '*.dba *.dlo *.dla *.dnm');

### Records sources and eventual inclusion directories
sub wanted($)
{
	state %file;
	my ($filename, $dirs, $suffix) = fileparse($_, qr/\.[^.]*/);
	if ($suffix =~ /^\.(?:c|ppc|h)$/)
	{		# Verify file is unique
		my $fullname = ${filename}.${suffix};
		die ("multi ${fullname}$RS") if defined $file{$fullname};
		$file{$fullname} = '';
		my $incl = File::Spec->canonpath(${File::Find::dir});
		$incl{$incl} = '';
		if ($suffix =~ /^\.(?:c|ppc)$/)
		{
			push @sources, $File::Find::name;
			push @sources_names, $filename
		}
	}
}

=head1 NAME

build - build a project hierarchy

=head1 SYNOPSIS

build.pl [options]

=head1 DESCRIPTION

Compiles all .c files in the whole project hierarchy.

=head1 NOTES

build.pm can define options.

=head1 OPTIONS

 -c --compiler <cc>		Compiler executable
			(default C:\GHS\PPC-V.R950\comp_201354\ccppc.exe)
 -f --cflags <c-flag>		Compiler option
 -I --inc <path>		Include path compiler option (default -I)
 -p --cppflags <cpp-flag>	C-Preprocessor flags
 -w --wa_relative		Work area is relative
    --nowa_relative		Wark area is absolute (default)

=head1 AUTOR

TechM

=head1 COPYRIGHT

(c) Copyright 2022 
