#!/usr/bin/env perl
# Description:	Analysis of dependencies in C or assembly
use 5.010001;
use strict;
use warnings FATAL => 'all';
require autodie;	# 'use' produce false warnings on files handlers
use Carp;
use English;
use POSIX;
use Getopt::Long;
use Cwd 'abs_path';
use File::Basename;
use File::Spec::Functions 'abs2rel';

our $opt_archive = '';		# Default don't use archive
our $opt_cmk;
our $opt_dest = '';
our $opt_incl_file;
our $opt_incl_flag = '-I';
our @opt_objects;
our $opt_sysinc;
my $layer;
sub depend($);

my $default_alarm_time = 600;
alarm $default_alarm_time;
my $version = '%version: 52 %';	# Special string updated by synergy
$version =~ s/^.*? | %//g;
our $VERSION = $version;
use FindBin;
push (@INC, $FindBin::RealBin);
require MM_common;
my %ext =
(
 	x => 'xsm',	# eXtended S-Motorola
	p => 'i',	# C preprocessed
	S => 'S',	# C preprocessing-Assembly
	s => 's',	# Assembly
	o => 'o',	# Object
	a => 'a',	# Archive
	i => ''		# Intermediate
);
Getopt::Long::Configure(qw(require_order no_pass_through no_bundling));
Getopt::Long::GetOptions(
	'archive|A!',			# Depend into library
	'dest|d=s',			# Destination, used in warning
	'ext|e=s%{,7}' => \%ext,	# File extensions
	'cmk|c=s',			# Dependencies command for C file
	'incl_file|i=s',		# include list file
	'incl_flag|I=s',		# Header directories list
	'objects|O=s@',			# Objects to be linked directly
	'sysinc|S=s',			# System headers paths
) or MM_common::help();
$OUTPUT_RECORD_SEPARATOR=$INPUT_RECORD_SEPARATOR;
my ($sysinc_regexp, $abs_sysinc_regexp);
if (defined $opt_sysinc)
{
	unless (-e $opt_sysinc)
	{
		warn "Missing system path '$opt_sysinc'$RS"
	}
	else
	{
		my $abs_sysinc = abs_path($opt_sysinc);
		unless (-d $abs_sysinc)
		{
			warn "Invalid system path '$opt_sysinc'$RS"
		}
		else
		{
			$sysinc_regexp = $opt_sysinc;
			$sysinc_regexp =~ s/[\\\.\?\+\*\(\)]/\\$&/g;
			$abs_sysinc_regexp = $abs_sysinc;
			$abs_sysinc_regexp =~ s/[\\\.\?\+\*\(\)]/\&/g
		}
	}
}
	# Traverse eventual symbolic links
my %unarchived_objects = map { $_ => 1 } @opt_objects;
$layer = $ARGV[0];
$layer //= '-';
$layer =~ s/\.[^.]*$//;
my @objs;
my %sources;
my %dd;
my %asap;
my %paths;
my $name;
my $path;
my $suffix;
my $t_standard;
foreach (<>)				# Scans sources list
{
	chomp;
	next if m/^BLACKLISTED /;
	($name, $path, $suffix) = fileparse($_, qr/\.[^.]*/);
	if ($suffix =~ /^\.(c|$ext{S}|$ext{s}|$ext{o}|$ext{x})$/)
	{			# C/assembly sources, objects or chaining to C
		die("double ${name}.\* in $path and $sources{$name}$RS")
						if exists $sources{$name};
		$sources{$name} = $path;
		&depend($_) unless $suffix eq ".$ext{o}";
					# Object not to be explicitly linked
		push @objs, "$name.$ext{o}"
			unless exists($unarchived_objects{"$name.$ext{o}"})
	}
	elsif ($suffix eq '.a2l')	# a2l source
	{
		my $name = $name.$suffix;
		die("double '$name' in $path and $asap{$name}$RS")
							if exists $asap{$name};
		$asap{$name} = $path;
	}
	elsif ($suffix eq '.dd')	# dd sources
	{
		my $name = $name.$suffix;
		die("double $name in $path and $dd{$name}$RS")
							if exists $dd{$name};
		$dd{$name} = $path
	}
}
					# Print dependencies
if (@objs)
{
	if ($opt_archive)
	{
		printf "\$(DEST)/$layer.$ext{a}: $layer.$ext{a}\(";
		my @dest_objs = map("\${DEST}/$_", @objs);
		print "@dest_objs\)"
	}
	else
	{
		print "\$(DEST)/$layer.$ext{a}: @objs"
	}
}
if (defined $opt_incl_file)
{
	my $unused_paths;
	my @incl_paths;
	open(STDIN, '<', "$opt_incl_file");	# Read layer's incl file
	push(@incl_paths, <STDIN>);
	close(STDIN);
	chomp @incl_paths;
	foreach (@incl_paths)
	{
		next if m/^\s*$/;
		$_ =~ s/\s*$opt_incl_flag\s*//;
		$_ = abs2rel($_);
		unless (exists $paths{$_})
		{
			warn "layer '${layer}[${opt_dest}]' apparently " .
						"unuse header path '$_'$RS";
			$unused_paths = ''
		}
	}
	warn "Headers paths reduction will reduce the compilation time$RS"
						if defined $unused_paths;
}
				# Print generic dd amd asap2 dependencies
$OUTPUT_FIELD_SEPARATOR = ' ';
my @dds = keys %dd;
print "\$(DEST)/$layer.dd: \$(TAB_BYPASS) \$(DEFS_FILES_$layer) " .
						"\$(TAB_NAME_$layer) @dds";
my @asap = keys %asap;
print "\$(DEST)/$layer.a2i: @asap";
exit 0;

my ($deps_cmd, $deps, $source);

# --- depend (name)
# Elaborate argument's dependencies computed by option 'cmk'.
sub depend($)
{
$source = $_;
unless ($suffix =~ /^\.(?:c|$ext{S})$/)
{
	$deps = ''	# $ext{s} $ext{o} $ext{x}
}
else
{
	my $source_regexp = "$name$suffix";
	$source_regexp =~ s/\./\\./g;
	die "-c option unspecified$RS" unless defined $opt_cmk;
	$deps_cmd = $opt_cmk . " $source";
	if ($Carp::Verbose>0)
	{
		warn("${source}$RS");
		warn("${deps_cmd}$RS") if $Carp::Verbose>1
	}
	{
		local $SIG{CHLD};
		$deps = qx($deps_cmd);
	}
# To work on slow hosts, after the 5th dependencies computing,
# update the default timeout based on actual performances;
# after the 100th one restart the timeout to account for long list
	$MM_common::opt_timeout=$MM_common::opt_timeout; # Hide false message
	unless (defined $MM_common::opt_timeout)
	{
		state $new_alarm_time = $default_alarm_time;
		if ((scalar @objs+1) == 100)
		{
			warn ("timeout for '${layer}[${opt_dest}]' restarted" .
				" with additional ${new_alarm_time}s " .
				"since now$RS")	if $Carp::Verbose>0;
			alarm $new_alarm_time
		}
		unless (defined $t_standard)
		{
			my ($user, $system, $cuser, $csystem) = times;
			my $childs_time = $cuser + $csystem;
			state $previous_childs_time = 0;
			my $child_time = $childs_time - $previous_childs_time;
			state $max_child_time = 0;
			$max_child_time = $child_time
						if $child_time>$max_child_time;
				# After the 5th (objs still to be increased)
			if ((scalar @objs+1) >= 5)
			{			# Standard single deps [s]
				$t_standard = 2.0;
				my $scale = $max_child_time / $t_standard;
				if ($scale > 5.0)
					{$scale = 5}
				elsif ($scale < 0.5)
					{$scale = 0.5}
				$new_alarm_time = int(($default_alarm_time*$scale)
									+ 0.5);
				if ($new_alarm_time != $default_alarm_time)
				{
					warn ("timeout for " .
						"'${layer}[${opt_dest}]' " .
						"scaled by $scale to " .
						"${new_alarm_time}s$RS")
							if $Carp::Verbose>0;
					alarm $new_alarm_time
				}
			}
		}
	}
	chomp $deps;
	if ($CHILD_ERROR)
	{
		my $message = "'$deps_cmd'";
		$RS //= "\n";	# To circumvent a bug in perl 5.10.1
		$message .= ":${RS}${deps}" if $deps;
		if (defined $opt_incl_file)
		{
			unlink $opt_incl_file
		}
		else
		{
			warn("If an include file was not found " .
						"recompute $layer.incl$RS");

		}
		die "'$source' dependencies error on ${message}${RS}"
	}
	warn("deps: ${deps}$RS") if $Carp::Verbose>1;
	$deps =~ s{^.*$}
	{
		$_ = $MATCH;
		if (m/(?:[^\w\s:\.\\\/]|^$)/)
		{		# Extract info, remarks, warnings and errors
			warn("${_}$RS") if $_;
			''
		}
		else
		{
				# Remove target (object) on every line
			s/^.*?:\s*//gm;
				# Remove eventual source name
			s/\b(.*[\\\/])?$source_regexp\b\s*//;
				# Remove eventual system headers
			s/(?:$sysinc_regexp|$abs_sysinc_regexp)\S+\s*//g
						if defined $abs_sysinc_regexp;
			$_
		}
	}gme;
				# Reduce dependencies on a single row
	$deps =~ s/\s*\\\r?\n\s*/ /g;
				# Remove eventual blanks at line begin and end
	$deps =~ s/(?:^\s+|\s+$)//g;
	my %local_names;	# All included files by current source
	warn("deps: ${deps}$RS") if $Carp::Verbose>1;
	$deps =~ s{([\w.\/]|\\.)+}
	{
		my ($name, $path, undef) = fileparse($MATCH, (''));
		warn("header: ${path}${name}$RS") if $Carp::Verbose>1;
		state %global_names;	# All included files in the analisys
		chop $path;
		$paths{$path}++;	# Record unique paths
				# Checks for the path/names uniqueness
		unless (exists $global_names{$name})
		{
			$global_names{$name} = $path
		}
		else
		{
			die ("double '$name' in '$global_names{$name}' and " .
				"'$path'$RS") if $global_names{$name} ne $path
		}
					# Leave only unique names
		unless (exists $local_names{$name})
		{
			$local_names{$name}='';
			$name
		}
		else
		{
			''			# Discard duplicated
		}
	}eg;
	$deps =~ s/\s+/ /g			# Shrinks spaces
}
if ($suffix =~ /^\.(?:c|$ext{x})$/)
{
	if ($suffix eq ".$ext{x}")
	{
		print ".SECONDARY: \$(DEST)/$name.c";	# keep it for analysis
		printf "\$(DEST)/$name.c "
	}
	printf "\$(DEST)/$name.$ext{i} " if $ext{i};
	printf "\$(DEST)/$name$_ "
		foreach (".$ext{p}", ".$ext{s}", '_lin.txt', '.eca', '.vectors')
}
elsif ($suffix eq ".$ext{S}")
{
	printf "\$(DEST)/$name.$ext{p} "
}
else	# ($suffix eq ".$ext{s}")
{
}
		# Object not to be explicitly linked
unless (exists($unarchived_objects{"$name.$ext{o}"}))
{
	printf "\$(DEST)/$layer.$ext{a}(\$(DEST)/$name.$ext{o}) "
							if $opt_archive;
}
print "\$(DEST)/$name.${ext{o}}: $deps" unless $suffix eq ".$ext{o}";
return
}

=head1 NAME

do_dep - dependencies for make use

=head1 SYNOPSIS

 do_dep [options] [sources list file(s)] (default is stdin)

=head1 DESCRIPTION

Compute and print C and assembly dependencies for make use.
Targets are .{p}, .{i}, .{s}, .o, .{a}(.o), .eca, .vectors and _lin.txt
Print .{x}, .a2l and .dd dependents (.{x} are dependents of .c).
Dependent into 'system_dir' will be excluded.
Paths are excluded (make have to use VPATH).
Objects will be dependent of archive.
Archive name is <layer>.<archive extension>
If compiler inclusion path are declared, with -i, paths are checked if unused.
Sources are extracted from the sources list file, if specified, or from stdin.
Eventual objects declared with -O will not be associated to the archive.

=head1 OPTIONS

 -A --archive		Dependent directly into layer
 -c --cmk dep_command	Dependencies preprocessor command (compulsory option)
 -d --dest destination	Used in warning
 -e --exts <k>=<v>	Compiler extensions; valid kyes and values are:
 	x => 'xsm',	# eXtended S-Motorola
	p => 'i',	# C preprocessed
	S => 'S',	# C preprocessing-Assembly
	i => ''		# Intermediate
	s => 's',	# Assembly
	o => 'o',	# Object
	a => 'a',	# Archive
 -I --incl_flag 	<include path compiler option> (default '-I')	
 -i --incl_file		Include list file (will be checked for unused paths)
 -O --objects object	Objects not to be archived
 -S --sysinc system_dir	System path

=head1 AUTOR

TechM

=head1 COPYRIGHT

(c) Copyright 2021 
